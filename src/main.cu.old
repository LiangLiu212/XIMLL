#include "TRandom.h"
#include "TH1F.h"
#include "TF1.h"
#include "TGraph.h"
#include "TCanvas.h"
#include "AngDisSS.hh"
#include "TFile.h"
#include "TStyle.h"
#include "TSystem.h"
#include "TVectorT.h"
#include "TStopwatch.h"
#include "TMath.h"
#include <TMinuit.h>
#include <vector>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <string>
#include <cstdlib>
#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#define THREADS_PER_BLOCK 1024
#define _SLOOW
Int_t NN1,NN2;
Int_t fit_nr;
Int_t fit_step = 0;
AngDisSS *angdis = 0;
std::vector<double> gDSmthe;
std::vector<double> gDpthe;
std::vector<double> gDpphi;
std::vector<double> gDapthe;
std::vector<double> gDapphi;
std::vector<double> gMSmthe;
std::vector<double> gMpthe;
std::vector<double> gMpphi;
std::vector<double> gMapthe;
std::vector<double> gMapphi;
std::vector<double> gDsW;
Int_t gNmax=64;
double w_alpha = 0;
using namespace std;
//=====================================================================
//
//================= GPU =====================

double *g_dSmthe, *g_dpthe, *g_dpphi, *g_dapthe, *g_dapphi, *g_dsW;

__global__  void gpu_aa(double *the, double *pthe, double *pphi, double *apthe, double *apphi, double *dsw, double *aa, int nn1, double p1, double p2, double p3, double p4){
		int index = blockIdx.x * blockDim.x + threadIdx.x;
		if(index < nn1){
#include "amplitude.cxx"
				aa[index] = tep;
		}
}


void ReadMC()
{
		int n2;
		Int_t nn = 0;
		double the_mc, pthe_mc, pphi_mc, apthe_mc, apphi_mc;
		fstream mcphsp("../data/PHSP2018.dat");
		std::string mcline;
		gMSmthe.clear();
		gMpthe.clear();
		gMpphi.clear();
		gMapthe.clear();
		gMapphi.clear();
		if(mcphsp.is_open()){
				while ( std::getline(mcphsp, mcline)){
						std::istringstream iss(mcline);
						if (!(iss >> n2 >> the_mc >> pthe_mc >> pphi_mc >> apthe_mc >> apphi_mc  )) { break; }
						nn++;
						gMSmthe.push_back(the_mc); 
						gMpthe.push_back(pthe_mc);  gMpphi.push_back(pphi_mc); 
						gMapthe.push_back(apthe_mc);  gMapphi.push_back(apphi_mc);
						angdis->AddToIntegral(the_mc, pthe_mc, pphi_mc, apthe_mc, apphi_mc);

				}
				NN2 = nn-1;
				std::cout << "NN2 " << NN2 << std::endl;
		}
		else
				cout << "unable to locate mc phsp-file!" << '\n';
		mcphsp.close();
}
void ReadData()
{
		// clear input data vectors


		gDSmthe.clear();
		gDpthe.clear();
		gDpphi.clear();
		gDapthe.clear();
		gDapphi.clear();
		gDsW.clear();

		int n1;
		double the, pthe, pphi, apthe, apphi, sW;
		Int_t nn=0;
		fstream sig("../data/sWeight_2012.dat"); 
		string sigline;
		if(sig.is_open()){
				while ( getline(sig, sigline) ){
						istringstream iss(sigline);
						if (!(iss >> n1 >> the >> pthe >> pphi >> apthe >> apphi >> sW  )) { break; }
						nn++;
						gDSmthe.push_back(the); 
						gDpthe.push_back(pthe);  gDpphi.push_back(pphi);
						gDapthe.push_back(apthe);  gDapphi.push_back(apphi);
						gDsW.push_back(sW);
				}
				NN1 = nn-1;
				std::cout << "NN1 " << NN1 << std::endl;
		}
		else
				cout << "unable to locate sig-file!" << '\n';
		Double_t a1 = 0;
		Double_t a2 = 0;
		double *dsmthe = new double [NN1];
		double *dpthe = new double [NN1];
		double *dpphi = new double [NN1];
		double *dapthe = new double [NN1];
		double *dapphi = new double [NN1];
		double *dsw = new double [NN1];
		for(int i = 0; i < NN1; i++){

				dsmthe[i] = gDSmthe[i];
				dpthe[i] = gDpthe[i];
				dpphi[i] = gDpphi[i];
				dapthe[i] = gDapthe[i];
				dapphi[i] = gDapphi[i];
				dsw[i] = gDsW[i];

				Double_t sW = gDsW[i];
				a1 += sW;
				a2 += sW*sW;
		}

		int size = NN1 * sizeof( double );
		cudaMalloc( (void **) &g_dSmthe, size );
		cudaMalloc( (void **) &g_dpthe, size );
		cudaMalloc( (void **) &g_dpphi, size );
		cudaMalloc( (void **) &g_dapthe, size );
		cudaMalloc( (void **) &g_dapphi, size );
		cudaMalloc( (void **) &g_dsW, size );

		cudaMemcpy( g_dSmthe, dsmthe, size, cudaMemcpyHostToDevice );
		cudaMemcpy( g_dpthe, dpthe, size, cudaMemcpyHostToDevice );
		cudaMemcpy( g_dpphi, dpphi, size, cudaMemcpyHostToDevice );
		cudaMemcpy( g_dapthe, dapthe, size, cudaMemcpyHostToDevice );
		cudaMemcpy( g_dapphi, dapphi, size, cudaMemcpyHostToDevice );
		cudaMemcpy( g_dsW, dsw, size, cudaMemcpyHostToDevice );

		delete []  dsmthe;
		delete []  dpthe;
		delete []  dpphi;
		delete []  dapthe;
		delete []  dapphi;
		delete []  dsw;

		w_alpha = a1/a2;
		sig.close();
}
void fcnMLLG(Int_t &npar, Double_t *gin, Double_t &f, Double_t *pp, Int_t iflag)
{ 
		angdis->SetParameter(pp);
		Double_t LogLike = 0;
		double *eval  = new double [NN1];
		double *gpu_eval;
		int size = NN1 * sizeof( double );
		cudaMalloc( (void **) &gpu_eval, size );

		gpu_aa <<< (NN1 + (THREADS_PER_BLOCK-1)) / THREADS_PER_BLOCK, THREADS_PER_BLOCK >>> ( g_dSmthe,  g_dpthe, g_dpphi, g_dapthe, g_dapphi, g_dsW, gpu_eval, NN1, pp[0], pp[1], pp[2], pp[3]);
		cudaMemcpy( eval, gpu_eval, size, cudaMemcpyDeviceToHost );
/*
		double diff = 0;
		for( int i = 0; i < NN1; i++ ){
				Double_t the  = gDSmthe[i];
				Double_t pthe 	 = gDpthe[i];
				Double_t pphi 	 = gDpphi[i];
				Double_t apthe 	 = gDapthe[i];
				Double_t apphi 	 = gDapphi[i];
				Double_t sW = gDsW[i];
				double cpu_eval = angdis->Amp(the, pthe, pphi, apthe, apphi);

				diff += fabs((cpu_eval - eval[i])/cpu_eval);


				if(eval[i] <= 0){ f=0; cout << "data : " << eval[i] << endl;  return; }
				LogLike -= gDsW[i]*TMath::Log(eval[i]);
		}

		cout << diff << endl;
		exit(0);
*/
		for( int i = 0; i < NN1; i++ ){
				if(eval[i] <= 0){ f=0; cout << "data : " << eval[i] << endl;  return; }
				LogLike -= gDsW[i]*TMath::Log(eval[i]);
		}


		Double_t norm=0;
		norm = angdis->CalcToIntegral();

		norm/=Double_t(NN2);
		LogLike += 2551950.*TMath::Log(norm);
		f=w_alpha * LogLike;
		delete [] eval;
		cudaFree( gpu_eval);

		if(fit_step%100 == 0){
				cout << norm << endl;
				for( int i = 0; i<4 ; i++ ) cout<<pp[i]<<" ";
				cout << endl;
				std::cout << "Loglike: " << LogLike << std::endl;
		}
		fit_step++;
}
//=====================================================================
// input [1] =  0; [2] =  type; [3] = step; [4] = output file
int main(int argc, char** argv){
		ofstream out;
		TString outfile_name = argv[1];
		cout << outfile_name << endl;
		out.open(outfile_name, ios::out | ios::app);
		// instantiating the values to be measured 
		//
		// starting values for fit
		Double_t Jpsi_alpha       = -0.355;    // alpha_J/Psi 
		Double_t Jpsi_phi       =  0.3;//-TMath::Pi()/4.; // relative phase, Dphi_J/Psi
		Double_t Sm_alpha     = -0.068;   // alpha (Sgm->p pi0)
		Double_t Sp_alpha     = 0.068;   
		angdis = new AngDisSS();
		ReadData();
		cout << "OK 11111111111" << endl;
		angdis->InitialInt();
		ReadMC();
		angdis->PrintInt();
		cout << "OK 11111111111" << endl;

		cout << "OK" << endl;
		// cout << argv[1] << endl;
		// fit nr is used to tell which analysis cuts that are used
		TMinuit *minuit=new TMinuit(4);
		Int_t ierflag=0; 
		Double_t arglist[100];
		cout << "OK 11111111111" << endl;
		minuit->SetFCN(fcnMLLG);
		cout << "OK 11111111111" << endl;
		arglist[0]= 0;
		minuit->mnexcm("SET PRINT",arglist,1,ierflag);
		arglist[0]= 0.5;
		minuit->mnexcm("SET ERR",arglist,1,ierflag);
		minuit->mnparm(0, "alpha_jpsi" ,Jpsi_alpha, 0.01, -1., 1., ierflag);
		minuit->mnparm(1, "dphi_jpsi", Jpsi_phi, 0.001, -TMath::Pi(), TMath::Pi(), ierflag);
		cout << "OK 11111111111" << endl;
		minuit->mnparm(2, "Sm_alpha" , Sm_alpha, 0.001, -1., 0., ierflag);
		minuit->mnparm(3, "Sp_alpha" , Sp_alpha, 0.001, 0, 1., ierflag);
		cout << "OK 11111111113" << endl;
		//minuit->mnparm(3, "A_CP" , A_CP, 0.001, 0.,0., ierflag); 
		// 	 		minuit->FixParameter(7);
		//		 minuit->FixParameter(9);
		//		 minuit->FixParameter(12);
		//		 minuit->FixParameter(13);
		cout << "OK 11111111114" << endl;
		minuit->mnexcm("MINI",arglist,0,ierflag); //minimization using the migrag
		cout << "OK 11111111115" << endl;
		//limits both 0 implies no limit 
		minuit->mnexcm("MINOS",arglist,0,ierflag);
		cout << "OK 11111111115" << endl;
		minuit->mnmatu(1);
		cout << "OK 11111111115" << endl;
		Double_t fmin, fedm, errdef;
		Int_t   npari, nparx, istat; 
		minuit->mnstat(fmin, fedm, errdef, npari, nparx, istat);
		double res[10], err_res[10];
		for(int p = 0; p < 4; p++)
				minuit->GetParameter(p, res[p], err_res[p]);
		out << fmin << "," << istat << "," << NN1 << ","<< NN2 << ","; 
		out << res[0]<< "," << err_res[0] << "," << res[1]<< "," << err_res[1]<< ","; 
		out << res[2]<< "," << err_res[2] << "," << res[3]<< "," << err_res[3]<< ",";
		out.close();
		return 1;
}
